'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
*  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*  http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*/

var WidgetChannelManager = function () {
    function WidgetChannelManager() {
        _classCallCheck(this, WidgetChannelManager);

        this.webSocket = null;
        this.widgetMap = {};
        this.subscribeWidget = this.subscribeWidget.bind(this);
        this.unsubscribeWidget = this.unsubscribeWidget.bind(this);
        this._initializeWebSocket = this._initializeWebSocket.bind(this);
        this._wsOnClose = this._wsOnClose.bind(this);
        this._wsOnError = this._wsOnError.bind(this);
        this._wsOnMessage = this._wsOnMessage.bind(this);
        this._initializeWebSocket();
        this.waitForConn = this.waitForConn.bind(this);
    }

    /**
     * Set a widget to the widget map and send configuration to the provider endpoint.
     * @param widgetId
     * @param callback
     * @param dataConfig
     */


    _createClass(WidgetChannelManager, [{
        key: 'subscribeWidget',
        value: function subscribeWidget(widgetId, callback, dataConfig) {
            var _this = this;

            this.widgetMap[widgetId] = callback;
            this.waitForConn(this.webSocket, function () {
                var configJSON = {
                    providerName: dataConfig.configs.type,
                    dataProviderConfiguration: dataConfig.configs.config,
                    topic: widgetId,
                    action: 'subscribe'
                };
                _this.webSocket.send(JSON.stringify(configJSON));
            });
        }

        /**
         * remove a widget from the widget map
         * @param widgetId
         */

    }, {
        key: 'unsubscribeWidget',
        value: function unsubscribeWidget(widgetId) {
            delete this.widgetMap[widgetId];
            var config = {
                topic: widgetId,
                providerName: null,
                dataProviderConfiguration: null,
                action: 'unsubscribe'
            };
            this.webSocket.send(JSON.stringify(config));
        }

        /**
         * Initialize websocket
         * @private
         */

    }, {
        key: '_initializeWebSocket',
        value: function _initializeWebSocket() {
            this.webSocket = new WebSocket('wss://' + window.location.host + '/data-provider');
            this.webSocket.onmessage = this._wsOnMessage;
            this.webSocket.onerror = this._wsOnError;
            this.webSocket.onclose = this._wsOnClose;
        }

        /**
         * handle web-socket on message event
         * @param message
         * @private
         */

    }, {
        key: '_wsOnMessage',
        value: function _wsOnMessage(message) {
            var data = JSON.parse(message.data);
            if (this.widgetMap[data.topic]) {
                this.widgetMap[data.topic](data);
            } else {
                // TODO: Error logging
            }
        }

        /**
         * handle web-socket on error event
         * @param message
         * @private
         */

    }, {
        key: '_wsOnError',
        value: function _wsOnError(message) {}
        // TODO: handle error message


        /**
         * handle web-socket on close event
         * @param message
         * @private
         */

    }, {
        key: '_wsOnClose',
        value: function _wsOnClose(message) {
            // TODO: handle on close event
        }
    }, {
        key: 'waitForConn',
        value: function waitForConn(socket, callback) {
            var that = this;
            setTimeout(function () {
                if (socket.readyState === 1) {
                    if (callback !== null) {
                        callback();
                    }
                } else {
                    that.waitForConn(socket, callback);
                }
            }, 1000);
        }
    }]);

    return WidgetChannelManager;
}();

var widgetChannelManager = new WidgetChannelManager();

exports.default = widgetChannelManager;